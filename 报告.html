<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>一个简单的PRC框架实现</title>
        <style>
/* From extension qiqiworld.vscode-markdown-tinymind */
.tinymap-topic {
    border-bottom: solid 0.15em #558ed5;
    padding: 0.2em 1.5em;
    font-weight: normal;
    font-size: 1em;
    margin: 0;
}

.tinymap-topic-level1 {
    border: solid 0.15em #558ed5;
    border-radius: 0.5em;
    padding: 0.4em 1.5em;
    font-weight: bold;
    font-size: 1.5em;
    background-color: #dce6f2;
    color: #376092;
}

.tinymap-topic-level2 {
    border: solid 0.1em #558ed5;
    border-radius: 0.5em;
    padding: 0.4em 1.5em;
    font-weight: bold;
    font-size: 1em;
    background-color: #dce6f2;
    color: #376092;
}

.tinymap-children .tinymap-topic {
    margin-left: 1.5em;
    margin-bottom: 0.2em;
}

.tinymap-topic-container {
    position: relative;
}

.tinymap-children .tinymap-topic-container::before {
    margin-top: -0.2em;
    content: '';
    display: block;
    position: absolute;
    top: 50%;
    height: 0.05em;
    width: 1.5em;
    background-color: #558ed5;
}

.tinymap-children>table:nth-child(1)>tbody>tr>.tinymap-topic-container:before {
    transform: rotate(-8deg);
    transform-origin: 0 0;
}

.tinymap-children>table:nth-last-child(1)>tbody>tr>.tinymap-topic-container::before {
    transform: rotate(8deg);
    transform-origin: 0.05em 0;
}

.tinymap-children>table:only-child>tbody>tr>.tinymap-topic-container::before {
    transform: none;
}

.tinymap-children table {
    position: relative;
}

.tinymap-children table::before {
    margin-top: -0.2em;
    content: '';
    display: block;
    position: absolute;
    top: 0;
    height: 100%;
    width: 0.05em;
    background-color: #558ed5;
}

.tinymap-children table:nth-child(1)::before {
    content: '';
    display: block;
    position: absolute;
    top: 50%;
    height: 50%;
    width: 0.05em;
    background-color: #558ed5;
}

.tinymap-children table:nth-last-child(1)::before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    height: 50%;
    width: 0.05em;
    background-color: #558ed5;
}

.tinymap-children table:only-child::before {
    content: none;
}

.tinymap-children {
    position: relative;
    margin-left: 0.3em;
    padding: 0;
}

.tinymap-children::before {
    margin-top: -0.2em;
    content: '';
    display: block;
    position: absolute;
    top: 50%;
    left: -0.3em;
    height: 0.05em;
    width: 0.3em;
    background-color: #558ed5;
}

.tinymap tr,
.tinymap td {
    padding: 0;
    margin: 0;
}

.tinymap table {
    border-collapse: collapse;
    border-spacing: 0;
}

.tinymap {
    white-space: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
}
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <h1 id="一个简单的prc框架实现">一个简单的PRC框架实现</h1>
<p>组员：杨涛，吴之玥，吴上，陈东林</p>
<h2 id="工作流程">工作流程</h2>
<ol>
<li>
<p>本地调用某个函数方法</p>
</li>
<li>
<p>本地机器的RPC框架把这个调用信息封装起来（调用的函数、入参等），序列化后，通过网络传输发送给远程服务器</p>
</li>
<li>
<p>远程服务器收到调用请求后，远程机器的RPC框架反序列化获得调用信息，并根据调用信息定位到实际要执行的方法，执行完这个方法后，序列化执行结果，通过网络传输把执行结果发送回本地机器</p>
</li>
<li>
<p>本地机器的RPC框架反序列化出执行结果，函数return这个结果
<img src="file:////Users/yangtao/Desktop/RPC/RPC/RPC.001.png" alt="RPC"></p>
</li>
</ol>
<h2 id="基于操作系统的socket和多线程编程">基于操作系统的socket和多线程编程</h2>
<p>对于远程调用来说，实际运行程序的被调用端，应同时应对多个服务请求，而且这些请求的执行不能相互干扰。</p>
<pre><code class="language-python"><div>    ip_port = (<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8000</span>)
    s = socketserver.ThreadingTCPServer(ip_port, MyServer)
    s.serve_forever()
</div></code></pre>
<p>多线程的TCP服务器将会并行执行调用请求，提高可用率</p>
<h2 id="基于jsonjavascript-object-notation的idlinterface-description-language实现">基于JSON(JavaScript Object Notation)的IDL(interface description language)实现</h2>
<p>JSON作为一种轻量级的数据交换语言，与XML一道，成为现代计算编程中最受欢迎的数据交换方式，它的跨语言特性十分适合作为RPC的IDL</p>
<pre><code class="language-JSON"><div>{
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"request"</span>,
    <span class="hljs-attr">"async"</span>:True,
    <span class="hljs-attr">"functionName"</span>: functionName,
    <span class="hljs-attr">"parameters"</span>: parameters
}
</div></code></pre>
<h2 id="跨语言的并发调用">跨语言的并发调用</h2>
<p>对于每一次调用，都会有一个唯一的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>u</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">uuid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，作为返回结果的定位。我们提供了同步(sync)和异步(async)两种调用方式。同步(sync)调用将会在调用后维持长连接，等待返回结果。异步(async)调用将会立刻返回结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>u</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">uuid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，以便以后访问计算结果。由于没有设置主动断开机制，同步调用将是不建议的。</p>
<p>我们分别完成了python和node.js的远程调用框架，两两之间通过JOSN屏蔽了语言的异构性。其中，python的并发机制采用了多线程(multi threading),而node.js的并发机制采用了天然异步，两种不同的并发机制都可以满足要求，因此我们都实现了。</p>
<h2 id="平台化">平台化</h2>
<p>该远程调用仅仅依赖基础库，安装解释器即可。对于调用的修改，我们使用了语言的反射机制(refect)，仅仅需要在服务器端，增加该调用方法的实现即可。</p>
<pre><code class="language-python"><div>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span><span class="hljs-params">(RPCServer)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, parameters)</span>:</span>
        print(<span class="hljs-string">"add"</span>)
        time.sleep(<span class="hljs-number">10</span>)
        result = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(parameters)):
            result = result + parameters[i]
        print(<span class="hljs-string">"add over"</span>)
        <span class="hljs-keyword">return</span> result
</div></code></pre>
<p>例如，只需要通过继承基础PRC调用框架，增加调用方法即可</p>
<h2 id="课程实验建议">课程实验建议</h2>
<p>对于RPC简易框架实验，可否更加明确需求，而非简单设立标准。</p>
<p>如：</p>
<ol>
<li>不能使用现有的RPC框架，必须基于操作系统Socket接口编程，具有一定“平台化”特点</li>
<li>不能只能调用一个特定方法</li>
<li>比如至少能只需要改动一点点就用于另一个方法</li>
</ol>
<p>以下不要求实现，但实现了可加分(可超出大作业环节的分数)</p>
<pre><code>• 跨语言调用能力 • IDL和IDL编译器 • 并发模型
</code></pre>
<p>修改为：</p>
<p>基于操作系统网络接口和基础库，完成并发的，可拓展的，跨语言，跨平台的无服务器云函数框架(Serverless Cloud Function)</p>
<p>无服务器(serverless)执行环境能够帮助用户在没有购买和管理服务器时仍能运行代码。用户只需要使用云平台支持的语言编写核心代码及设置代码运行的条件，代码即可在腾讯云基础设施上弹性、安全地运行，并可完全管理底层计算资源，包括服务器CPU、内存、网络、代码部署、弹性伸缩、负载均衡等服务。使用无服务器云函数将可免除所有运维性操作，企业和开发者可以更加专注于核心业务的开发，实现快速上线和迭代，把握业务发展的节奏。</p>

    </body>
    </html>